# rack_algorithm

## The Problem

In summer of 2024, a researcher at a local hospital expressed to me their desire for a rack distribution algorithm. They often deal with hundreds of racks at a time, each of which contains anywhere from 1 to 96 samples. Typically, there are a lot of racks with just 1 or 2 samples, but this frequency decreases drastically as the sample number increases. The researcher's task is to combine racks with fewer samples into others, filling them up as much as possible (up to 96 samples per rack), while also minimizing the number of batches they work in. Each batch can have up to 20 racks, and these racks can be a mix of "source" racks (the ones being emptied) and "destination" racks (the ones being filled). For example, they might combine 19 source racks into 1 destination rack, or 18 source racks into 2 destination racks, etc.

## The Solution - Overview

Using the provided sample distribution data, I developed a C++ console program that efficiently combines source racks into destination racks, grouping them into batches of 20. The algorithm analyzes the frequency of sample sizes in the source racks to determine how many racks to combine in each batch and how to fill the destination racks. The program's results were successful, creating 42 batches from 777 racks, with most destination racks being filled to capacity.

## The Solution - Details

The algorithm starts by reading the rack data and creating a Source_Rack object for each line, initializing its ID and sample number. Each Source_Rack is then added to the back of an all_sources vector. The program uses this vector to gather information about how many racks contain each sample size, storing the data in a sample_frequencies unordered map. The Source_Rack and sample_frequencies structures are part of the Program class, along with a Batch class that holds a list of Source_Racks. Additionally, there's a testing_array vector that the program uses to experiment with different sample combinations. As numbers are added to or removed from the testing_array, the sample frequencies array is updated accordingly. Note that the testing_array only contains integers representing the sample numbers from the source racks — no actual source racks are added to the batch until the combination is finalized.

To minimize the number of batches required to cover all the source racks, the program selects the maximum number of source racks for each batch. It starts by adding the largest sample number available to the testing array to represent the largest-sample rack and fills the remaining spots with the lowest sample numbers available. For example, if the largest source rack has 94 samples, there are at most 18 spots left, which the program fills with 1's (or whatever sample numbers are the current lowest). This would result in a total of 112 samples in the batch, exceeding the 96 spots available in a single destination rack. Since using 19 source racks allows for only 1 destination rack, the program must try with 18 source racks instead. With 18 source racks, it can create 2 destination racks, providing 192 spots. In this case, the total sample sum is 111, which fits within the 192 available spots, so this option is chosen.

After determining the number of source racks in a Batch, the program empties the testing array and begins adding sample numbers. First it adds the highest sample number, and then it calculates the ratio of each sample number's frequency to the total sample sum of the available racks, truncating the result to an integer. Using this ratio, it adds a proportional amount of each sample number. If there is more than 1 spot left, it fills all but one of the remaining spots with the lowest sample numbers available. Note: There is a potential bug if there is an unexpectedly high number of racks with high sample numbers. In this case, the use of ratios may result in no extra spots being available, which is essential for the next step.

The program then calculates the ideal last sample number and checks its availability using the sample_frequencies map. If the sample number is available, it adds it to the testing array. Next, for each value in the testing array, the program searches through the all_sources vector and adds a Source Rack with the corresponding sample number to the batch. After adding a rack, it removes that source rack from all_sources, updates the sample_frequencies map, and then moves on to the next batch.

If the ideal last spot is not available, the program first checks if the last spot is less than 1. If it is, the program decreases the total sample number in the testing array by removing a larger number and adding a smaller one, repeating this process until the last spot is greater than 1 and available. If the last spot is not less than 1, the program increases the total sample number in the testing array by removing the smallest sample number and adding a larger one, continuing this until the last spot becomes available or the number to add reaches the highest sample number available. If it reaches the highest sample number and the total in the testing array still doesn’t meet the goal, the program approximates by adding the largest sample number available. While the rack may not be completely full, it will likely be close. After finalizing the spots, the program moves on to the next batch.

Once the number of source racks left is fewer than 19, the program distributes them by adding as many racks as possible to a batch without exceeding the available destination spots (remember that the number of spots available decreases as the number of Source Racks in the batch increases). When the limit is reached, a new batch is created, and this process continues until all Source Racks have been distributed.

After distributing all the racks, the program asks the user if they would like an overview. The overview describes the number of batches, the count of source and destination racks in each batch, and the number of filled spots in the destination racks for each batch. Finally, it exports the final results to a .csv file, detailing the rack IDs and sample number of each source rack in each batch, along with the total number of spots filled in each batch.

## Notes about compiling and running
Ensure that Visual Studio is installed and the "Desktop development with C++" workload is selected. Then, select "Build" in Visual Studio to build the program and "Debug" to run it.

Input file should be a .txt file. Each line should have a new source rack with a string for the rack id, followed by a space and a numeric value from 1 to 96 indicating the number of samples in the rack. See input file rack_data.txt for an example.

Place the input file in the "Debug" folder that is generated when Visual Studio builds the project. This is also where the output file (a .csv file) should be located once the program creates it.

Program may have bugs if there are large sample numbers with unexpectedly high frequencies in the source rack data.
